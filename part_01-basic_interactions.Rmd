---
title: "Basic Interactions"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The only meaningful way of interacting with R is by typing code into the R console. R's command prompt is a ‘>’ sign. When present, R is waiting for the next line of code. 

The prompt looks like this:

```
> _
```

In the absence of the prompt, R is busy with calculations. Anything you type in meanwhile, will be evaluated _after_ the current command has completed.

In case a line is (syntactically) incomplete after you hit the return key, R will continue the next line with a ‘+’ waiting for you to complete the command.

> If at any point you want to abort the execution of a running command, or if you cannot figure out how to correctly complete the current line of input, hit Ctrl + C.

## Code and Comments

In the following, you will see pieces of R code (‘chunks’) in grey boxes. You can copy and paste this code to your R console and execute it by yourself. For the sake of reproducibility, some of the chunks are directly followed by the output you should obtain on your machine. Here, these lines are prefixed with a ‘##’ mark.

> In R, the ‘#’ sign serves as comment character. Anything typed behind this sign will be invisible to R. 

## Expressions and Assignments

Code to interact with R will fall into one of two categories.

_Expressions:_

```{r}
1 + sin(pi/2) 
nchar("math") # number of characters in the word “math”
```

_Assignments:_
  
```{r eval=FALSE}
x = 1  # right-hand side (RHS) is assigned to left-hand side (LHS)

y <- 2 # RHS is assigned to LHS
3 -> z # LHS is assigned to RHS
```

### Expressions

When expressions are typed, R will evaluate them and return the result. 

Expressions can be (but are not limited to) mathematical expressions in a colloquial sense. Thus, R can be used as a very fancy calculator. Some of the arithmetic operators implemented in R include:

| operator | effect |
| ---------|----------|
| `+` | addition |
| `-` | subtraction |
| `*` | multiplication |
| `/` | division |
| `%/%` | integer division |
| `%%` | modulo (remainder) |
| `^` or `**` | exponention |

```{r eval=FALSE}
13 %/% 4
13 %% 4

# check out the result of these ‘tricky’ cases
1/0
1/0 + 1/0
(-8)^(1/3)
```

There are many (a lot of!) built-in functions for other mathemtatical operations including `abs(...)`, `floor(...)`, `round(...)`, `sqrt(...)`, `exp(...)`, `log(...)`, `sin(...)`, `cos(...)`, etc. R is designed to work out boolean and matrix algebra, and offers a large statistical toolbox.

R follows the standard order of operations, groupings based on parentheses.

```{r eval=FALSE}
6 + 9 / 3
(6 + 9) / 3
```

***

Within the `tidyverse` (or `magrittr`), there is also another way to specify the order in which expressions are evaluated. Namely, by ‘**piping**’ the different operations in the very order they must be executed by R. The ‘pipe’ is designated by the `%>%` operator. This operator is so useful that it has its own key-binding in RStudio, which is Ctrl/Cmd + Shift + M.

We can obtain the same result as above with

```{r message=FALSE, eval=FALSE}
library(magrittr) # allow to use pipe

9 %>% divide_by(3) %>% add(6) 
6 %>% add(9) %>% divide_by(3)
```

Piping is very effective, when multiple functions would be nested.

```{r eval=FALSE}
# compare ...
asin(sqrt(divide_by(sum(1, 2, 3, 4), 10)))

# ... and ...
sum(1, 2, 3, 4) %>% 
  # comments may be interspresed to give rationales
  divide_by(10) %>% 
  # functions with a single argument, may omit brackets ...
  sqrt %>% 
  asin
```

We will see how to use piping when it comes to data manipulation.

### Assignments

While using R as a calculator is interesting, to do useful things, we need to assign _values to objects_. In R, the assignment operator `<-` (or `->`) points from the value to the object. The ‘=’ sign can also be used for assignments.

Objects can be given any (case-sensitive) ‘name’ (also known as the object's ‘symbol’), except that

* names cannot start with a number, and
* names cannot be identical to reserved words such as `if`, `TRUE`, `NA`, `...` etc. (type `?Reserved` for a complete list).

> Beware that you might unintentionally **overwrite built-in objects** such as `mean`, `data`, `df` etc. When in doubt, check the help to see if the name is already in use. RStudio will show you a list of all currently loaded object and function names starting with the word you typed when you hit the tab key. 

In practice, you want your object names to be explicit and not too long. 

```{r}
N_Avogrado = 6.022e23 # we cannot use NA as name!

N_fmol = 2
N_abs  = N_fmol * N_Avogrado * 1e-15

# print the result
N_abs
```

You can see which objects are currently loaded in R's memory (‘Global Environment’) checking the ‘Environment’ tab in RStudio or by typing `ls()` in the R console.

To remove objects from R's memory, use the `rm(...)` function.

```{r}
ls()
rm(N_abs, N_Avogrado)
ls()
```

### Functions

If a set of operations will be repeatedly used, it can be useful to summarize these as a function. The return value of the function will dependend on the arguments the function is called with. 

A function is created with `function(...) {...}`. As every R object, functions can be assigned to a name for future reference. The arguments (variables _and_ parameters) on which the function depends, are written between the round brackets of the call, the operations to execute follow in curly brackets.

```{r}
fmol_to_abs <- function(fmol) {
  
  N_Avogrado = 6.022e23
  
  N_abs = fmol * N_Avogrado * 1e-15
  
  return(N_abs)
  
}

fmol_to_abs(N_fmol)
```

Note that neither `N_abs` nor `N_Avogrado` have been added to the ‘Global Environment’. 

```{r}
ls()
```

If the last statement in a function is an expression, it is implicitly returned. So, we could simplify.

```{r}
fmol_to_abs <- function(fmol) {
  
  N_Avogrado = 6.022e23
  
  fmol * N_Avogrado * 1e-15
  
}

fmol_to_abs(N_fmol)
```

Of course, it is possible to add parameters to a function. These parameters can have default values.

```{r}
mol_to_abs <- function(mol, prefix = "f") {
  
  prefix_meaning = c("a" = 1e-18,
                     "f" = 1e-15, 
                     "p" = 1e-12,
                     "n" = 1e-09,
                     "µ" = 1e-06,
                     "m" = 1e-03)
  
  mol * 6.022e23 * prefix_meaning[[prefix]]
  
}

# the default "f" is assumed for the omitted prefix parameter
mol_to_abs(N_fmol) 
# with the prefix specified, the default is ignored
mol_to_abs(20, prefix = "µ")
# unnamed arguments are interpreted in the order of the function's definition; 
# when named, arguments can be provided in any order
mol_to_abs(prefix = "µ", mol = 20)
```

## Packages

Not all functions are loaded by default into R's memory. Also, not all functionality required for a certain task might even be programmed in base R. Therefore, users can write, deposit and load ‘extensions’ to the R software, which most frequently comes as a bundle of functions (and/or data) in so-called ‘packages’. 

Packages can be found anywhere in the internet, but most reliably, they are obtained from the ‘Comprehensive R Archive Network’ ([CRAN](https://cran.rstudio.com)) and in many cases actively maintained and developed by the community on github. 

To install, e.g. the `magrittr` package from CRAN.

```{r eval=FALSE}
install.packages("magrittr")
```

To uninstall a package, use `remove.packages(...)`.

To load a package into R's memory, use

```{r eval=FALSE}
library("magrittr")
```

All of its functions will now be available: Their namespace has been attached to the search path of the current environment. To check the currently loaded namespaces, type `loadedNamespaces()`. To remove a namespace from the current session, type `unloadNamespace(...)` providing the package name.

If you intend to use a single function from a package only once, or if there are multiple functions with the same name from different packages loaded in the current namespace, you can be more explicit, prefixing the package name with `::` before the function call, e.g. `magrittr::divide_by(...)`. 


### Getting Help on Functions and Other Objects

To ‘see’ the code that a function executes, just type its name without the bracktes into the R console.

```{r}
mol_to_abs
```

As this code can be sometimes rather enigmatic, each function comes with an extensive built-in documentation within R. 

***

_If you know the command's name,_ the following approach will open the appropriate documentation. As an example, examine the help for the `sum(...)` function.

```{r eval=FALSE}
help(sum)
help("sum")
?sum
```

Typically, the help page includes the following sections:

* _Description_, a brief summary,
* _Usage_, showing all arguments (variables and parameters) along with their default values, where `...` represents any abitrary number of comma-separated (unquoted) arguments,
* _Arguments_, explicitly describing each argument and the data type expected,
* _Details_, summarizing the function's behaviour and its intended usage,
* _Value_, explicitly describing the return value of the function,
* _References_ for the algorithms implemented,
* _See Also_, listing similar functions for different data types, or shortcuts for commonly used operations,
* _Examples_ with illustrative code that helps better understanding the functions behavior.

***

_If you do not know the exact name of the function you are looking for,_ but you know what the function _should_ be able to do for you, the following commands will be helpful.

```{r}
help.search("histogram")
??histogram
```
