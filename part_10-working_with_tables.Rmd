---
title: "Working with Tables"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

A ‘table’---in R called a `data.frame`---is organized in columns and rows. Each column of a `data.frame` can hold only a _single_ [data type](part_02-data_structures.md#data-types-in-r), but columns can have _different_ data types. `data.frame` objects are thus created _by column_. Technically speaking, a [`data.frame` is a `list`](part_02-data_structures.html#advanced-data-structures-classes) in which each element of the list is an atomic vector of the same length.

There are (at least) three different flavours to work with a `data.frame` objects in R:

1. Base R uses `list`-like syntax; this can however easily get cumbersome to work with.
2. The*`data.table` package uses SQL-like syntax to access `data.table` objects, a class similar to `data.frame`, but built for maximum efficiency. 
3. The `dplyr` package uses language-like syntax to describe the actions applied to `tibble` objects, another class similar to `data.frame`.

We will focus on using `dplyr`, which is part of the `tidyverse`.

```{r}
library(tidyverse)
```

> Note that the `tidyverse` makes extensive use of ‘quasiquotation’. This means that you can refer e.g. to column names (which are usually of type `character`) without using quotation marks (`""` or `''`). But beware, some arguments accept `character` vectors only. These must be quoted.

> Related to this, you might see underscore versions of some `tidyverse` commands popping up in RStudio's command completion such as `spread_` for `spread`. Ignore them (and any resource on the internet that urges you to use them), they are superfluous (``?tidyr::`deprecated-se` ``).

The `tidyverse` also imports [the pipe `%>%`](part_01-basic_interactions.html#using-a-pipe) from the `magrittr` package.

## Motivation: A Typical Table in Biosciences

_“The plate is the experimental default table in the Biosciences.”_

In the worst case, the data acquired from each position (well, spot, etc.) on the plate was saved like this:

```{r echo=FALSE, message=FALSE}

# === simulate some linear dose ~ response data with noise ===

# --- number of concentrations measured ---

dose <- c(10**(3:0), 0)
names(dose) <- paste("conc", c(1:(length(dose) - 1), 0), sep = "_")

# --- number of conditions measured ---

# effect sizes
cond <- rep(c(0, 2, 40, 10, 0), each = 2)
names(cond) <- paste(rep(c("control", paste("treatment", LETTERS[1:4], sep = "_")), 
                         each = 2), c(1, 2), sep = ".")

# generate random table (set 1)

set.seed(1757)

sapply(cond, function(i) rnorm(dose, mean = i * log10(dose + 1), sd = .4) )%>% 
  round(digits = 3) %>% 
  data.frame(row.names = names(dose)) %>% t %>% 
  data.frame() %>% 
  cbind(table_id = paste("table", rep(c(1, 1, 2, 2, 3), each = 2), sep = "_")) %>% 
  as_tibble(rownames = "sample_id") %>% 
  separate("sample_id", sep = "\\.", into = c("sample_id", "replicate_id")) %>% 
  mutate(replicate_id = str_c("replicate_", replicate_id)) -> all_plates.1

# generate random table (set 2)

set.seed(8041)

sapply(cond, function(i) rnorm(dose, mean = i * log10(dose + 1), sd = .4) )%>% 
  round(digits = 3) %>% 
  data.frame(row.names = names(dose)) %>% t %>% 
  as_tibble(rownames = "exp_id") %>%
  select(exp_id, conc_2, conc_0) -> all_plates.2

# plate_1 is wide without assignments

plate_1 <- all_plates.1 %>% 
  filter(table_id == "table_1") %>% select(-table_id) %>% 
  as.data.frame()

# plate_2 is wide with assignments

plate_2 <- all_plates.1 %>% 
  filter(table_id == "table_2") %>% select(-table_id) %>% 
  as.data.frame()

# plate_3 is wide with assignments, but mixed

plate_3 <- all_plates.1 %>% 
  filter(table_id == "table_3") %>% select(-table_id) %>% 
  select(sample_id, replicate_id, conc_1, conc_3, conc_2, conc_4, conc_0) %>% 
  as.data.frame()

# plate_4 is randomized order different style without treatment_D.2

set.seed(120853)

plate_4 <- all_plates.2 %>% 
  filter(exp_id != "treatment_D.2") %>% 
  sample_n(nrow(.)) %>% 
  as.data.frame()

rm(cond, list = ls(pattern = "all_plates"))

# print the unlabelled table (works also with plate_2 etc.)

plate_1 %>% 
  mutate(anonymous = str_c("<b>", 1:nrow(.), "</b>")) %>% 
  select(-ends_with("id")) %>% 
  select("anonymous", everything()) %>% 
  knitr::kable(format = "markdown", align = "c",
               col.names = c(" ", LETTERS[1:ncol(.) - 1]))
```

Certainly, the sample assignments were documented (somewhere), so that we know _the actual data_ should be annotated like this.

```{r echo=FALSE}
plate_1 %>% 
  mutate_at(vars(ends_with("id")), ~str_c("<b>", ., "</b>")) %>% 
  knitr::kable(format = "markdown", align = "c",
               col.names = c(" ", " ", colnames(.)[3:ncol(.)]))
```

Imagine this data appearing in some spreadsheet software. 

1. How easily could you incorporate the concentrations actually used in the experiment, which were `r paste(names(dose), paste(dose, "µM"), sep = " = ", collapse = ", ")`?
2. Would you be able to calculate the mean and standard deviation of the replicates for all samples?
3. Would it take long to plot the dependence of the measured value on the concentration?
4. Could you easily exclude a set of replicates and check the outcome? How about adding another set of observations and answer all the same questions?

The following answer takes just four lines of code in R …

```{r echo=FALSE}
plate_1 %>% 
  # -- start counting --
  gather(key = "concentration", value = "intensity", -sample_id, -replicate_id) %>% 
  mutate(concentration = str_c(dose[concentration], " µM")) %>% 
  group_by(sample_id, concentration) %>% 
  summarize(mean = round(mean(intensity), 3), sd = round(sd(intensity), 3)) %>% 
  # -- stop counting --
  knitr::kable(format = "markdown", align = "r")
```

… and six more lines for a plot.

```{r echo=FALSE, fig.height=4, fig.width=5}
plate_1 %>% 
  gather(key = "concentration", value = "intensity", -sample_id, -replicate_id) %>% 
  mutate(concentration = dose[concentration]) %>% 
  # -- start counting --
  ggplot(aes(x = concentration + 1, y = intensity, color = sample_id)) +
  geom_smooth(method = lm, se = FALSE, size = .5) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_summary(fun.data = mean_sdl, geom = "linerange") +
  stat_summary(fun.data = mean_sdl, geom = "point") +
  scale_x_log10() + 
  # -- stop counting --
  theme_classic(base_size = 12) + theme(
    axis.ticks  = element_line(colour = "black"),
    axis.text   = element_text(size = 12, colour = "black"),
    legend.text = element_text(size = 12)
  )
```

So, let's start!

```{r include=FALSE}
plate_1 <- plate_1 %>% 
  select_at(vars(starts_with("conc"))) %>% 
  as.data.frame()

colnames(plate_1) <- LETTERS[1:ncol(plate_1)]

# save some plates as csv

lapply(ls(pattern = "plate_[1-3]"), function(x) write_csv(
  eval(as.name(x)), path = str_c("./part_10-working_with_tables_files/", x, ".csv")))

# save assignments as RData

save(plate_4, dose, file = "./part_10-working_with_tables_files/plates.RData")

rm("dose", list = ls(pattern = "plate_"))
```

## Importing Data from Delimited Files

### Importing Data from a Single File

The data for the plate shown above has been saved in a comma-delimited file called ‘plate_1.csv’. In the sub-folder ‘part_10-working_with_tables_files’. Let's import this file using `readr::read_csv()`; it will try to guess the data type stored in each column.

In the file path, `.` refers to the current working directory (`getwd()`), so that we can use relative paths.

```{r}
plate_1 <- read_csv(file = "./part_10-working_with_tables_files/plate_1.csv")
plate_1
```

The column names have been assigned from the first line of the file (since they were text). However, as we know the column names, we should use them. We can either set them using `colnames(plate_1)<-`, or provide them during import, skipping the first line of the file.

```{r}
plate_1 <- read_csv(file = "./part_10-working_with_tables_files/plate_1.csv",
                    col_names = str_c("conc_", c(1:4, 0)), skip = 1)
```

It is disencouraged to use row names to work with data, since only one variable or parameter can be stored. So, let's add one column specifying the sample type and one column specifying the replicate number.

```{r}
plate_1 %>% 
  add_column(sample_id = rep(c("control", "treatment_A"), each = 2),
             replicate_id = rep(str_c("replicate_", c(1, 2)), times = 2),
             # insert before first column; default after last column
             .before = 1)
```

If you had rownames assigned to your table that you want to keep, use `dplyr::rownames_to_column()`. 

### Importing Data from Multiple File

A nice feature of using a programmatic approach for data analysis is that it will enable you to retrieve (systematically) many files from multiple locations (e.g. reflecting multiple experiments) on your harddrive and to either analyze them in identical ways one by one, or to combine them for analysis. 




### Importing Data from Excel

To read data from Excel, you can use `readxl::read_excel(...)` or `XLConnect::readWorksheetFromFile(...)`. 

However, I would disencourage to do so routinely, since `.xls` and `.xlsx` are neither open (i.e. disclosed), nor standardized. This means they can be changed by Microsoft anytime and may consequently not be (immediately) supported by these packages.

Another problem, you might be facing is that within Excel it is tempting to put multiple  tables with different data side-by-side in a single worksheet. To import such worksheets  will require a lot of polishing work from your side after.

> **Advice:** Keep one set of data per sheet and export a CSV file from Excel.

# ---------------------------

The data for this plate has been saved in a file called ‘plates.RData’. When you open this file, there should be (at least) one object called `plate_1` and a named vector called `dose` in the ‘Global Environment’.

```{r}
load(file = "./part_10-working_with_tables_files/plates.RData")
```

* Which class and data type do these objects belong to?

## Tidy Data

Data can be tabulated in one of two ways: A tidy and a messy one.

> If each variable forms a column, and each row represents a single observation, and each cell a single value, we refer to this as **tidy data**. 

Having your data tidied is crucial for facilitating data manipulation, modelling, and visualization!

Here are some guidelines:

1. Don't use values as column headers, all column headers should be variable names.
2. Don't put multiple variables in a single column.
3. Don't store variables in both rows and columns.
4. Avoid storing multiple types of observational units in the same table.

Typically, if the table with your data is wider than long (if it is in the ‘wide format’), it's likely to encounter messy data. For example, `plate_1` is in one (of many possible) messy formats: The concentration is spread along the header row, not in a separate column. 

A tidyer ‘wide format’ of the same data would look like that:

```{r echo=FALSE}
plate_1 %>% 
  pivot_longer(cols = -one_of("replicate_id", "sample_id"), 
               names_to  = "concentration", values_to = "intensity") %>% 
  pivot_wider(names_from = sample_id, values_from = intensity) %>% 
  mutate(replicate_id  = str_c("<b>", replicate_id, "</b>"),
         concentration = str_c("<b>", concentration, "</b>"),) %>% 
  head(7) %>% 
  knitr::kable(format = "markdown", align = "c")
```

_(table abridged)_

The longer the table, the tidyer the data. Here is the ‘long format’ of `plate_1`:

```{r echo=FALSE}
plate_1 %>% 
  pivot_longer(cols = -one_of("replicate_id", "sample_id"), 
               names_to= "concentration", values_to = "intensity") %>% 
  mutate(sample_id     = str_c("<b>", sample_id, "</b>"),
         replicate_id  = str_c("<b>", replicate_id, "</b>"),
         concentration = str_c("<b>", concentration, "</b>"),) %>% 
  head(9) %>% 
  knitr::kable(format = "markdown", align = "c")
```

_(table abridged)_

The `tidyr` package (part of the `tidyverse`) provides functions to help you tidy messy data. In this R session, the package has already been attached to your namespace.

### Interconverting Wide and Long Table Formats

The degree to which you want to make your table ‘longer’ than ‘wide’ depends on the manipulation you want to perform. Typically, the ‘longest format’ serves as the linchpin to produce the ‘wider formats’.

For your convenience, this is an overview of the different functions that are around to interconvert wide and long table formats. (In case you encounter one of these or need help on related topics.)

| action | `tidyr` ≥ v1.0 | `tidyr` < v1.0 | `data.table` | `reshape`/`reshape2` |
|--------|------------------|------------------|--------------|----------------------|
| make wide table long (‘melting’) | `pivot_longer()` | `gather()` | `melt()`  | `melt()` |
| make long table wide (‘casting’) | `pivot_wider()`  | `spread()` | `dcast()` | `acast()`, `dcast()` |

As many people don't find the other function names intuitive, we will use `tidyr::pivot_longer(...)` and `tidyr::pivot_wider(...)`. 

```{r}
plate_1 %>% 
  # make wide table long
  pivot_longer(cols = conc_1:conc_0,        # selection of columns
               names_to  = "concentration", # name that describes the parameter in the selected headers
               values_to = "intensity"      # name that describes the value in the selected cells
  ) %>% 
  # print only top rows
  head(3)
```

Instead of selecting the columns `conc_1:conc_0`, we could have specified the columns which _not_ to gather; these are somtimes called the ‘identifying (id) columns’. The following commands evaluate to the same result.

```{r eval=FALSE}
plate_1 %>% 
  # select by column index
  pivot_longer(cols = 3:7)

plate_1 %>% 
  # select by name range
  pivot_longer(cols = conc_1:conc_0)

plate_1 %>% 
  # select explicitly positive
  pivot_longer(cols = c("conc_1", "conc_2", "conc_3", "conc_4", "conc_0"))

plate_1 %>% 
  # select explicitly negative
  pivot_longer(cols = -c("sample_id", "replicate_id"))

plate_1 %>% 
  # select using pattern
  pivot_longer(cols = starts_with("conc"))
```

We will see more ways to select column names later.

For now, let's next spread the gathered representation of `plate_1` into a wide format! Maybe, we would like to see the measured intensities for `control` and `treatment_A` side-by-side given each concentration and the replicate.

```{r}
plate_1 %>% 
  # make wide table long
  pivot_longer(conc_1:conc_0, names_to = "concentration", values_to = "intensity") %>% 
  # make long table wide
  pivot_wider(names_from  = "sample_id", # column to use content as new column headers
              values_from = "intensity"  # column to use content to populate the new cells with
             ) %>% 
  # print only top rows
  head(3) 
```

You can check out more examples in the [`tidyr` vignette on pivoting](https://tidyr.tidyverse.org/dev/articles/pivot.html).

The format of `plate_1` from above can be useful if we wanted to subtract the intensities measured in the control from the ones in the treated samples. Here, `dplyr::mutate(...)` creates a new column or modifies an exisiting column using the specified operations.

```{r}
plate_1 %>% 
  # make wide table long
  pivot_longer(conc_1:conc_0, names_to = "concentration", values_to = "intensity") %>% 
  # make long table wide
  pivot_wider(names_from = "sample_id", values_from = "intensity") -> plate_1.wide

plate_1.wide %>% 
  # make new column with corrected treatment_A values
  mutate(tratment_A.corrected = treatment_A - control) %>% head(3)

plate_1.wide %>% 
  # operate in place; not always advisable
  mutate(treatment_A = treatment_A - control) %>% head(3)
```

### Uniting and Splitting Columns

The `tidyr::unite(...)` function takes multiple column names and pastes the column contents together. 

```{r}
plate_1 %>% 
  unite(col = "experiment",      # column to create
        sample_id, replicate_id, # columns to paste, can be unquoted
        sep = "/"                # separator, "_" is the default
  ) %>% 
  # print only top rows
  head(3)
```

The `tidyr::separate(...)` function does the reverse. By default, any non-alphanumeric character will be used to split the column. Note that missing pieces will be replaced with `NA`.

```{r}
plate_1 %>% 
  separate(col  = sample_id,                 # column to split, can be unquoted
           into = c("treatment", "specimen") # names of the new columns
  ) %>% 
  # print only top rows
  head(3)

plate_1 %>% 
  unite("experiment", sample_id, replicate_id, sep = "/") %>% 
  separate(experiment, into = str_c("piece_", 1:5)) %>% 
  # print only top rows
  head(3)
```

## Combining Tables

In the current environment, you should have additional plates, `plate_2` and `plate_3`, which we would like to combine with `plate_1`. Let's check their organization first.

```{r}
plate_2
plate_3
```

Apparently, `plate2` has the same organization as `plate1`, so we could combine them effortless. For `plate_3`, two columns have been swapped, which could cause problems if we don't pay attention. Luckily, R pays attention for you.

The command to combine rows is `rbind(...)` in base R and `dpylr::bind_rows(...)` in the `tidyverse`. Let's save this as `all_plates`.

```{r}
plate_1 %>% bind_rows(plate_2, plate_3) -> all_plates
```

To combine columns, you may use `cbind(...)` or `dplyr::bind_cols(...)` respectively. However, you must be absolutely sure that the rows align!

```{r eval=FALSE}
bind_cols(
  all_plates %>% select(sample_id, replicate_id, conc_1),
  all_plates %>% select(conc_4, conc_2, conc_2, conc_0, conc_3)
)
```

A more represenative case would look like this. (Don't care too much about how to create the randomized halfs.)

```{r}
# half plate with conc_0 and conc_4 measurments
half_1 <- all_plates %>% sample_n(nrow(.)) %>% 
            select(sample_id, replicate_id, conc_0, conc_4)
# half plate with conc_3, conc_4 and conc_0 measurments
half_2 <- all_plates %>% sample_n(nrow(.)) %>% 
            select(sample_id, replicate_id, conc_3, conc_1, conc_2)

# this will be wrong
cbind(half_1, half_2)
```

To properly merge `half_1` and `half_2`, we would like to use the colums named `sample_id` and `replicate_id` as indices. This is what `dplyr::inner_join(...)` does.

```{r}
# this will be correct
inner_join(half_1, half_2, by = c("sample_id", "replicate_id"))
```

If you want to keep rows that are only in one table, but not in another, there are also the functions `dpylr::left_join()` and `dplyr::right_join()`. (Having both options is useful when you pipe the commands.)

## Manipulating Columns (“Table Variables”)

### Selecting Columns

To select a column, you can always type its name between quotation marks. Most functions will also accept unquoted column names (mostly, when `...` is allowed).

In addition, there are helper functions to select multiple columns at once.

They are documented in `?select_helpers`.

| operator/function | selection |
|-------------------|--------|
| `everything` | all columns |
| `last_col` | last column |
| `one_of` | these column names as character vector |
| `starts_with` | column names starting with this prefix literally |
| `ends_with` | column names ending with this suffix literally |
| `contains` | column names containing this string literally |
| `matches` | column names matching the regular expression |
| `:` | all columns between |
| `-` | all columns except |


For ‘scoped’ summarizing (`summarize_at`) and mutating verbs (`mutate_at`), you will need to wrap your statement in `vars(...)` to use any of the above.

For ‘scoped’ filtering verbs (`filter_all` or `filter_if`), there are additional variants called `all_vars(...)` and `any_vars(...)`.

### Extracting Columns

You will need basically

* `select` to (optionally rename and) extract columns as table, or
* `pull` to extract column values of _one_ column as a vector; which defaults to the last column is none is specified.

There are the ‘scoped’ variants, 

* `select_all` to rename all columns (e.g. make uppercase),
* `select_at` to (optionally rename and) extract columns select with `vars(...)`, and
* `select_if` to (optionally rename and) extract columns that meet a certain property, (e.g. contain integer values).

### Making New Columns

The following will apply _vectorized_ functions to columns


Subtracting `control` from all treatments would work the very same as above. (We look into this later.)

```{r eval=FALSE}
all_plates %>% 
  # make wide table long
  pivot_longer(conc_1:conc_0, names_to = "concentration", values_to = "intensity") %>% 
  # make long table wide
  pivot_wider(names_from = "sample_id", values_from = "intensity") %>% 
  # subtract control in place
  mutate_at(vars(starts_with("treatment")), funs(. - control))
```
