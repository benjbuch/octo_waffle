---
title: "Working with Tables"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

A ‘table’, in R called a `data.frame`, is organized in columns and rows. Each column can hold only a _single_ data type; but columns can have _different_ data types. `data.frame`s are thus created _by column_. (Technically speaking, `data.frame`s are `list` objects in which each element of the list is an atomic vector of the same length.)

There are (at least) three different flavours to work with `data.frame` in R:

1. Base R uses `list`-like syntax to access `data.frame` objects; this can however easily get cumbersome to work with.
2. The **`data.table` package**, which uses SQL-like syntax to access `data.table` objects, a class similar to `data.frame`, but built for maximum efficiency. 
3. The **`dplyr` package**, which uses language-like syntax to describe the actions applied to `tibble` objects, another class similar to `data.frame`.

We will focus on using `dplyr`, which is part of the `tidyverse`.

```{r}
library(tidyverse)
```

> Note that in the `tidyverse` you will see extensive use of quasiquotation. This means you can refer e.g. to column names (which are usually `character`) without quotation marks (`""` or `''`). Though, some arguments accept `character` vectors only. These must be quoted.

> Related to this, you might see underscore versions of some `tidyverse` commands popping up in RStudio's command completion. Ignore them.

## A Typical Table in Biosciences

The plate is the experimental default table in the Biosciences. 

In the worst case, the data acquired from each position (well, spot, etc.) on the plate is saved like this:

```{r echo=FALSE, message=FALSE}

# simulate some linear dose ~ response data with noise

set.seed(1757)

dose <- c(10**(3:0), 0)
names(dose) <- paste("conc", c(1:4, 0), sep = "_")

cond <- rep(c(0, 2, 40, 10, 0), each = 2)
names(cond) <- paste(rep(c("control", paste("treatment", LETTERS[1:4], sep = "_")), 
                         each = 2), c(1, 2), sep = ".")

sapply(cond, function(i) rnorm(dose, mean = i * log10(dose + 1), sd = .4) )%>% 
  round(digits = 3) %>% 
  data.frame(row.names = names(dose)) %>% t %>% 
  data.frame() %>% 
  cbind(table_id = paste("table", rep(c(1, 1, 2, 2, 3), each = 2), sep = "_")) %>% 
  as_tibble(rownames = "sample_id") %>% 
  separate("sample_id", sep = "\\.", into = c("sample_id", "replicate_id")) %>% 
  mutate(replicate_id = str_c("replicate_", replicate_id)) -> all_plates

plate_1 <- all_plates %>% 
  filter(table_id == "table_1") %>% select(-table_id) %>% 
  as.data.frame()

plate_2 <- all_plates %>% 
  filter(table_id == "table_2") %>% select(-table_id) %>% 
  as.data.frame()

plate_3 <- all_plates %>% 
  filter(table_id == "table_2") %>% select(-table_id) %>% 
  select(sample_id, replicate_id, conc_1, conc_3, conc_2, conc_4, conc_0) %>% 
  as.data.frame()

rm(cond, all_plates)

save(plate_1, plate_2, plate_3, dose, file = "./part_10-working_with_tables_files/plates.RData")

# print the unlabelled table

plate_1 %>% 
  mutate(anonymous = str_c("<b>", 1:nrow(.), "</b>")) %>% 
  select(-ends_with("id")) %>% 
  select("anonymous", everything()) %>% 
  knitr::kable(format = "markdown", align = "c",
               col.names = c(" ", LETTERS[1:ncol(.) - 1]))
```

Of course, the sample assignments have been documented (somewhere). So, we know that _the actual data_ should be annotated like this.

```{r echo=FALSE}
plate_1 %>% 
  mutate_at(vars(ends_with("id")), ~str_c("<b>", ., "</b>")) %>% 
  knitr::kable(format = "markdown", align = "c",
               col.names = c(" ", " ", colnames(.)[3:ncol(.)]))
```

Imagine this data appearing in some spreadsheet software. 

1. How easily could you incorporate the information of the concentrations, which was `r paste(names(dose), paste(dose, "µM"), sep = " = ", collapse = ", ")`?
2. Would you be able to calculate the mean and standard deviation of the replicates for all samples?
3. Would it take long to plot the dependence of the measured value on the concentration?
4. Could you test-wise exclude a set of replicates and check the outcome? How about adding another set of observations and answer all the same questions?

The following calculation takes four lines of code in R …

```{r echo=FALSE}
plate_1 %>% 
  # -- start counting --
  gather(key = "concentration", value = "intensity", -sample_id, -replicate_id) %>% 
  mutate(concentration = str_c(dose[concentration], " µM")) %>% 
  group_by(sample_id, concentration) %>% 
  summarize(mean = round(mean(intensity), 3), sd = round(sd(intensity), 3)) %>% 
  # -- stop counting --
  knitr::kable(format = "markdown", align = "r")
```

… and six more lines for the plot.

```{r echo=FALSE, fig.height=4, fig.width=5}
plate_1 %>% 
  gather(key = "concentration", value = "intensity", -sample_id, -replicate_id) %>% 
  mutate(concentration = dose[concentration]) %>% 
  # -- start counting --
  ggplot(aes(x = concentration + 1, y = intensity, color = sample_id)) +
  geom_smooth(method = lm, se = FALSE, size = .5) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_summary(fun.data = mean_sdl, geom = "linerange") +
  stat_summary(fun.data = mean_sdl, geom = "point") +
  scale_x_log10() + 
  # -- stop counting --
  theme_classic() + theme(
    axis.ticks = element_line(colour = "black"),
    axis.text  = element_text(size = 11, colour = "black"),
    legend.text = element_text(size = 11)
  )
```

So, let's start!

The data for this plate has been saved in a file called ‘plates.RData’. When you load this file to R's memory (the ‘Global Environment’), there should be (at least) one object called `plate_1` and a named vector called `dose`.

```{r}
load(file = "./part_10-working_with_tables_files/plates.RData")
```

Which class and data type do these objects belong to?

## Tidy Data

Data can be tabulated in one of two ways: A tidy and a messy one.

> If each variable forms a column and each row represents a single observation, we refer to this as **tidy data**. 

Having your data tidied is crucial for facilitating data manipulation, modelling, and visualization!

Here are some guidelines:

1. Don't use values as column headers, all column headers should be variable names.
2. Don't put multiple variables in a single column.
3. Don't store variables in both rows and columns.
4. Avoid storing multiple types of observational units in the same table.

Typically, if the table with your data is wider than long (if it is in the ‘wide’ format), it's easy to encounter messy data. For example, `plate_1` is in one (of many possible) wide and messy formats: The parameter concentration is stored along the header row, not in a separate column. 

A tidyer wide format would look like that:

```{r echo=FALSE}
plate_1 %>% 
  gather(key = "concentration", value = "intensity", -sample_id, -replicate_id) %>% 
  spread(sample_id, intensity) %>% 
  mutate(replicate_id = str_c("<b>", replicate_id, "</b>"),
         concentration= str_c("<b>", concentration, "</b>"),) %>% 
  head(7) %>% # rbind(c("<em>(abridged)</em>", "", "", "")) %>% 
  knitr::kable(format = "markdown", align = "c")
```

_(table abridged)_

The longer the table (‘long’ format), the tidyer the data:

```{r echo=FALSE}
plate_1 %>% 
  gather(key = "concentration", value = "intensity", -sample_id, -replicate_id) %>% 
  mutate(sample_id    = str_c("<b>", sample_id, "</b>"),
         replicate_id = str_c("<b>", replicate_id, "</b>"),
         concentration= str_c("<b>", concentration, "</b>"),) %>% 
  head(9) %>% # rbind(c("<em>(abridged)</em>", "", "", "")) %>% 
  knitr::kable(format = "markdown", align = "c")
```

_(table abridged)_

The `tidyr` package (part of the `tidyverse`) provides functions to help you tidy your data. In this session, the package has already been attached to the namespace.

### Interconverting Wide and Long Table Formats

The degree to which you want to make your table ‘longer than wide’ depends on the manipulation you want to perform. Typically, the ‘longest’ format serves as the linchpin to produce the ‘wider’ formats.

* `tidyr::gather(...)` will gather information presented along the rows into a column. Sometimes this process is also called ‘melting’ because of the equivalent `data.table::melt(...)` function.
* `tidyr::spread(...)` will do the reverse: It makes long tables wide. Another term is ‘casting’ because of the `data.table::dcast(...)` and `reshape2::acast(...)` functions.

```{r}
plate_1 %>% 
  # make wide table long
  gather(key   = "concentration", # name of the column describing the parameter in column headers
         value = "intensity",     # name of the column describing the value in the table body
         conc_1:conc_0            # gather all columns between conc_1 and conc_0
         ) %>% 
  # print only top rows
  head(3)
```

Instead of selecting the columns `conc_1:conc_0`, we could have specified the columns which _not_ to gather; these are somtimes called the ‘identifying columns’. The following commands evaluate to the same result.

```{r eval=FALSE}
plate_1 %>% 
  gather(key = "concentration", value = "intensity", 3:7) # by column index

plate_1 %>% 
  gather(key = "concentration", value = "intensity", conc_1:conc_0) # by name range

plate_1 %>% 
  gather(key = "concentration", value = "intensity", conc_1, conc_2, conc_3, conc_4, conc_0) # explicit positive

plate_1 %>% 
  gather(key = "concentration", value = "intensity", -sample_id, -replicate_id) # explicit negative
```

Let's next spread the gathered representation of `plate_1` into a wide table! Maybe, we would like to see the measured intensities for `control` and `treatment_A` side-by-side given each concentration and the replicate.

```{r}
plate_1 %>% 
  # make wide table long
  gather(key = "concentration", value = "intensity", conc_1:conc_0) %>% 
  # make long table wide
  spread(key   = sample_id, # the (unquoted) names of columns to use as column headers
         value = intensity, # the (unquoted) names of columns to populate the table body
         ) %>% 
  # print only top rows
  head(3) 
```

